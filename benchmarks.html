<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Community Comparison Dashboard</title>
  <!-- Bootstrap CSS for styling -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" />
  <!-- Chart.js for charting -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Papa Parse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <style>
    body { padding-top: 60px; }
    .navbar { margin-bottom: 20px; }
    /* One-column layout */
    .chart-container { text-align: center; margin-top: 20px; }
    .table-container { margin-top: 20px; }
    #benchmarksTable { font-size: 0.8rem; }
    #benchmarksTable th, #benchmarksTable td { padding: 8px; border: 1px solid #ddd; }
    #benchmarksTable th { background-color: #f2f2f2; }
  </style>
</head>
<body>
  <!-- Navigation Bar -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
    <a class="navbar-brand" href="#">Community Comparison</a>
  </nav>
  
  <div class="container mt-5">
    <!-- Dropdown Section -->
    <div class="row">
      <div class="col-12">
        <h3>Community Data</h3>
        <div class="form-group">
          <label for="indicatorSelect">Select Indicator:</label>
          <select class="form-control" id="indicatorSelect"></select>
        </div>
      </div>
    </div>
    <!-- Chart Section (on top) -->
    <div class="row">
      <div class="col-12">
        <div class="chart-container">
          <h3>Indicator Chart</h3>
          <canvas id="indicatorChart" width="600" height="300"></canvas>
        </div>
      </div>
    </div>
    <!-- Table Section (below the chart) -->
    <div class="row">
      <div class="col-12">
        <div class="table-container">
          <h3 class="mt-4">Indicator Data Table</h3>
          <table class="table table-bordered" id="benchmarksTable">
            <thead></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Bootstrap JS and dependencies (for mobile navbar functionality) -->
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
  
  <script>
    const DEBUG = true;
    let benchmarksData = [];
    let indicatorChart = null;
    
    // Consolidated indicators object.
    const consolidatedIndicators = {
      "Property Values": {
        columns: [
          "FY2025 Residential Property Values",
          "FY2025 Open Space Property Values",
          "FY2025 Commercial Property Values",
          "FY2025 Industrial Property Values",
          "FY2025 Personal Property Values",
          "FY2025 Total Property Value"  // Used in table but excluded from chart.
        ]
      },
      "Tax Rates by Class": {
        columns: [
          "Residential Tax Rate",
          "Open Space Tax Rate",
          "Commercial Tax Rate",
          "Industrial Tax Rate",
          "Personal Property Tax Rate"
        ]
      },
      "Expenses by Function": {
        columns: [
          "General Government Expenses",
          "Police Expenses",
          "Fire Expenses",
          "Other Public Safety Expenses",
          "Education Expenses",
          "Public Works Expenses",
          "Human Services Expenses",
          "Culture and Recreation Expenses",
          "Fixed Costs Expenses",
          "Intergovernment Expenses",
          "Other Expenses",
          "Debt Service Expenses"
        ]
      },
      "Tax Levies by Class": {
        columns: [
          "Residential Levy",
          "Open Space Levy",
          "Commercial Levy",
          "Industrial Levy",
          "Personal Prop Levy"
        ]
      }
    };
    
    // Load benchmarks CSV using Papa Parse.
    function loadBenchmarksData() {
      Papa.parse("benchmarks.csv", {
        download: true,
        header: true,
        complete: function(results) {
          benchmarksData = results.data;
          if (DEBUG) console.log("Benchmarks CSV loaded:", benchmarksData);
          populateIndicatorDropdown();
          if (benchmarksData.length > 0) {
            const initialIndicator = document.getElementById("indicatorSelect").value;
            updateDashboard(initialIndicator);
          }
        },
        error: function(err) {
          console.error("Error loading benchmarks CSV:", err);
        }
      });
    }
    
    // Populate dropdown with indicator names.
    function populateIndicatorDropdown() {
      const select = document.getElementById("indicatorSelect");
      select.innerHTML = "";
      if (benchmarksData.length === 0) return;
      
      // Build a set of all column names used in consolidated indicators.
      const consolidatedCols = new Set();
      Object.values(consolidatedIndicators).forEach(ind => {
        ind.columns.forEach(col => consolidatedCols.add(col));
      });
      
      // Add consolidated indicators first.
      Object.keys(consolidatedIndicators).forEach(key => {
        let option = document.createElement("option");
        option.value = key;
        option.textContent = key;
        select.appendChild(option);
      });
      
      // Then add individual indicators (all CSV headers except "Community" and those in consolidatedCols)
      // Also skip "Total Levy" since it's already part of "Tax Levies by Class".
      const headers = Object.keys(benchmarksData[0]);
      headers.slice(1).forEach(header => {
        if (!consolidatedCols.has(header) && header !== "Total Levy") {
          let option = document.createElement("option");
          option.value = header;
          option.textContent = header;
          select.appendChild(option);
        }
      });
      
      select.addEventListener("change", function() {
        updateDashboard(this.value);
      });
    }
    
    // Update dashboard (chart and table) based on selected indicator.
    function updateDashboard(indicator) {
      if (DEBUG) console.log("Selected indicator:", indicator);
      if (isConsolidated(indicator)) {
        let { labels, datasets } = getConsolidatedChartData(indicator);
        drawStackedChart(labels, datasets, indicator);
        updateTableForConsolidated(indicator, labels, datasets);
      } else {
        let labels = [];
        let dataValues = [];
        benchmarksData.forEach(row => {
          labels.push(row["Community"] || "Unknown");
          let value = parseFloat(row[indicator]);
          dataValues.push(isNaN(value) ? 0 : value);
        });
        drawBarChart(labels, dataValues, indicator);
        updateTableForIndividual(indicator, labels, dataValues);
      }
    }
    
    function isConsolidated(indicator) {
      return consolidatedIndicators.hasOwnProperty(indicator);
    }
    
    // For consolidated indicators, build stacked datasets and sort by total sum in ascending order.
    function getConsolidatedChartData(indicator) {
      let cols = consolidatedIndicators[indicator].columns;
      // For "Property Values", exclude the "FY2025 Total Property Value" column from the chart.
      if (indicator === "Property Values") {
        cols = cols.filter(col => col !== "FY2025 Total Property Value");
      }
      // Build an array of rows with aggregated values.
      let rows = [];
      benchmarksData.forEach(row => {
        let community = row["Community"] ? row["Community"].trim() : "Unknown";
        let values = [];
        let total = 0;
        cols.forEach(col => {
          let raw = row[col] ? row[col] : "0";
          let value = parseFloat(raw.replace(/[\$,]/g, ""));
          value = isNaN(value) ? 0 : Math.round(value);
          values.push(value);
          total += value;
        });
        rows.push({ community, values, total });
      });
      // For additive indicators, sort by total in ascending order.
      if (indicator === "Property Values" || indicator === "Expenses by Function" || indicator === "Tax Levies by Class") {
        rows.sort((a, b) => a.total - b.total);
      }
      let labels = rows.map(r => r.community);
      // Rebuild dataset arrays based on sorted order.
      let datasetMap = {};
      cols.forEach(col => { datasetMap[col] = []; });
      rows.forEach(row => {
        for (let i = 0; i < cols.length; i++) {
          let col = cols[i];
          datasetMap[col].push(row.values[i]);
        }
      });
      const defaultColors = [
        "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f"
      ];
      let datasets = [];
      cols.forEach((col, index) => {
        datasets.push({
          label: col,
          data: datasetMap[col],
          backgroundColor: defaultColors[index % defaultColors.length]
        });
      });
      if (DEBUG) console.log("Consolidated Chart Data for", indicator, ":", { labels, datasets });
      return { labels, datasets };
    }
    
    // Draw a stacked bar chart.
    function drawStackedChart(labels, datasets, indicator) {
      const ctx = document.getElementById("indicatorChart").getContext("2d");
      if (indicatorChart) { indicatorChart.destroy(); }
      indicatorChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  if (indicator === "Property Values" || indicator === "Tax Levies by Class") {
                    return context.dataset.label + ": " + formatDollar(context.parsed.y);
                  }
                  return context.dataset.label + ": " + context.parsed.y;
                }
              }
            },
            legend: { position: "bottom" }
          },
          scales: {
            x: { stacked: true, title: { display: true, text: "Community" } },
            y: { stacked: true, beginAtZero: true, title: { display: true, text: "Value" } }
          }
        }
      });
    }
    
    // Draw a regular bar chart for individual indicators.
    function drawBarChart(labels, dataValues, indicator) {
      const ctx = document.getElementById("indicatorChart").getContext("2d");
      if (indicatorChart) { indicatorChart.destroy(); }
      indicatorChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: [{
            label: indicator,
            data: dataValues,
            backgroundColor: "rgba(54, 162, 235, 0.5)",
            borderColor: "rgba(54, 162, 235, 1)",
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  return indicator + ": " + context.parsed.y;
                }
              }
            },
            legend: { position: "bottom" }
          },
          scales: { y: { beginAtZero: true } }
        }
      });
    }
    
    // Helper: Remove $ and commas then parse as float; return 0 if missing.
    function extractValue(val) {
      if (!val) return 0;
      let s = val.toString().replace(/\$/g, "").replace(/,/g, "").trim();
      let num = parseFloat(s);
      return isNaN(num) ? 0 : Math.round(num);
    }
    
    // Helper: Format a number as currency.
    function formatDollar(value) {
      return "$" + Math.round(value).toLocaleString("en-US");
    }
    
    // Update table for individual indicators (Community + indicator column).
    function updateTableForIndividual(indicator, labels, dataValues) {
      const table = document.getElementById("benchmarksTable");
      const thead = table.querySelector("thead");
      const tbody = table.querySelector("tbody");
      thead.innerHTML = "";
      tbody.innerHTML = "";
      let headerRow = "<tr><th>Community</th><th>" + indicator + "</th></tr>";
      thead.innerHTML = headerRow;
      benchmarksData.forEach((row, index) => {
        let community = row["Community"] ? row["Community"].trim() : "Unknown";
        let value = dataValues[index];
        let formatted = value;
        if (indicator === "Property Values") {
          formatted = formatDollar(value);
        }
        let rowHTML = "<tr><td>" + community + "</td><td>" + formatted + "</td></tr>";
        tbody.innerHTML += rowHTML;
      });
    }
    
    // Update table for consolidated indicators: show Community and each component column.
    function updateTableForConsolidated(indicator, labels, datasets) {
      const table = document.getElementById("benchmarksTable");
      const thead = table.querySelector("thead");
      const tbody = table.querySelector("tbody");
      thead.innerHTML = "";
      tbody.innerHTML = "";
      const cols = consolidatedIndicators[indicator].columns;
      
      // Build header row using a for-loop.
      let headerRow = "<tr><th>Community</th>";
      for (let i = 0; i < cols.length; i++) {
        headerRow += `<th>${cols[i]}</th>`;
      }
      headerRow += "</tr>";
      thead.innerHTML = headerRow;
      
      // Build data rows.
      let rowsHTML = "";
      for (let i = 0; i < benchmarksData.length; i++) {
        let row = benchmarksData[i];
        let community = row["Community"] ? row["Community"].trim() : "Unknown";
        let rowHTML = `<tr><td>${community}</td>`;
        for (let j = 0; j < cols.length; j++) {
          let col = cols[j];
          let raw = row[col] !== undefined ? row[col] : "0";
          let value = extractValue(raw);
          if (indicator === "Property Values" || indicator === "Tax Levies by Class") {
            rowHTML += `<td>${value !== 0 ? formatDollar(value) : 0}</td>`;
          } else {
            rowHTML += `<td>${value !== 0 ? value : 0}</td>`;
          }
        }
        rowHTML += "</tr>";
        rowsHTML += rowHTML;
      }
      tbody.innerHTML = rowsHTML;
      if (DEBUG) console.log("Updated consolidated table for", indicator, "with rows:", rowsHTML);
    }
    
    window.onload = function() {
      loadBenchmarksData();
    };
  </script>
</body>
</html>
